<!DOCTYPE html>
<html>
<head>
  <script src="d3.js"></script>

  <style>
    #boundary_circle {
      fill: none;
      stroke: grey;
      stroke-width: 1px;
      stroke-dasharray: 5 2;
    }

    .active:hover {
      filter: drop-shadow(0 0 5px rgba(0, 0, 0, 1));
    }

    .vertex {
      stroke: black;
      stroke-width: 2px;
    }

    .edge {
      stroke: black;
      stroke-width: 1px;
    }

    .unfilled {
      fill: white;
    }

    .filled {
      fill: black;
    }
    #paper {
      border: 1px solid grey;
    }


    .selected {
      filter: drop-shadow(0 0 5px rgba(0, 0, 0, 1));
    }

  </style>
</head>
<body>

<button id="btn-new" onclick="newGraph()">New</button>
<button id="btn-export" onclick="exportData()">Export data as json</button>
<button id="btn-tikz" onclick="exportTikz()">Export tikz to clipboard</button>
<div id="paper-container"></div>

<br>
<button id="btn-deselect" onclick="deselect()">Deselect all</button>
<button id="btn-move" onclick="activateButton(this,'move')">Move</button>
<button id="btn-place_filled" onclick="activateButton(this,'place_filled')">Place filled vertex</button>
<button id="btn-place_unfilled" onclick="activateButton(this,'place_unfilled')">Place unfilled vertex</button>
<button id="btn-toggle_color" onclick="activateButton(this,'toggle_color')">Toggle vertex color</button>
<button id="btn-add_edge" onclick="activateButton(this,'place_edge')">Add edge</button>
<button id="btn-add_hourglass" onclick="activateButton(this,'place_hourglass')">Add hourglass</button>
<button id="btn-add_khourglass" onclick="activateButton(this,'place_khourglass')">Add k-hourglass</button>
<!--<textarea id= "tikz" style= "border-width: medium;"></textarea>-->



<script>
const radius = 10;
/*var data = {
   vertices: [{
     id: 0,
     x: 20,
     y: 15,
     type: "filled"
   }, {
     id: 1,
     x: 14,
     y: 30,
     type: "unfilled"
   }, {
     id: 2,
     x: 30,
     y: 30,
     type: "filled"
   }, {
     id: 3,
     x: 30,
     y: 18,
     type: "unfilled"
   }, {
     id: 4,
     x: 100,
     y: 100,
     type: "unfilled"
   }],
   edges: [{
     sourceId: 0,
     targetId: 1,
     weight: 1
   }, {
     sourceId: 1,
     targetId: 2,
     weight: 4
   }, {
     sourceId: 2,
     targetId: 3,
     weight: 2
   }, ]
 };*/

 /*var data = {"vertices":[{"x":-16,"y":70,"id":4,"type":"filled"},{"x":6,"y":61,"id":5,"type":"filled"},{"x":23,"y":49,"id":6,"type":"filled"},{"x":35,"y":20,"id":7,"type":"filled"},{"x":-73,"y":-46,"id":8,"type":"filled"},{"x":36,"y":-7,"id":9,"type":"filled"},{"x":26,"y":-25,"id":10,"type":"filled"},{"x":7,"y":-47,"id":11,"type":"filled"},{"x":-22,"y":-61,"id":12,"type":"filled"},{"x":-51,"y":-54,"id":13,"type":"filled"},{"x":-76,"y":-27,"id":14,"type":"filled"},{"x":-83,"y":-4,"id":15,"type":"filled"},{"x":-82,"y":23,"id":16,"type":"filled"},{"x":-71,"y":47,"id":17,"type":"filled"},{"x":-55,"y":62,"id":18,"type":"filled"},{"x":-36,"y":68,"id":19,"type":"filled"},{"x":-36,"y":49,"id":20,"type":"unfilled"},{"x":-9,"y":54,"id":21,"type":"unfilled"},{"x":-15,"y":43,"id":22,"type":"filled"},{"x":-60,"y":29,"id":23,"type":"unfilled"},{"x":-41,"y":29,"id":24,"type":"filled"},{"x":-21,"y":24,"id":25,"type":"unfilled"},{"x":-18,"y":9,"id":26,"type":"filled"},{"x":-46,"y":-7,"id":27,"type":"filled"},{"x":-20,"y":-20,"id":28,"type":"filled"},{"x":-10,"y":-5,"id":29,"type":"unfilled"},{"x":-39,"y":9,"id":30,"type":"unfilled"},{"x":-38,"y":-20,"id":31,"type":"unfilled"},{"x":7,"y":-20,"id":32,"type":"unfilled"},{"x":-58,"y":-35,"id":33,"type":"unfilled"}],"edges":[{"weight":2,"sourceId":22,"targetId":21},{"weight":1,"sourceId":21,"targetId":4},{"weight":1,"sourceId":21,"targetId":5},{"weight":1,"sourceId":22,"targetId":20},{"weight":1,"sourceId":20,"targetId":19},{"weight":1,"sourceId":20,"targetId":18},{"weight":1,"sourceId":17,"targetId":23},{"weight":1,"sourceId":23,"targetId":16},{"weight":1,"sourceId":24,"targetId":20},{"weight":1,"sourceId":25,"targetId":22},{"weight":1,"sourceId":25,"targetId":24},{"weight":2,"sourceId":23,"targetId":24},{"weight":1,"sourceId":25,"targetId":6},{"weight":1,"sourceId":30,"targetId":26},{"weight":1,"sourceId":30,"targetId":15},{"weight":1,"sourceId":27,"targetId":31},{"weight":1,"sourceId":28,"targetId":29},{"weight":2,"sourceId":26,"targetId":29},{"weight":2,"sourceId":28,"targetId":31},{"weight":2,"sourceId":27,"targetId":30},{"weight":1,"sourceId":26,"targetId":25},{"weight":1,"sourceId":7,"targetId":29},{"weight":1,"sourceId":32,"targetId":11},{"weight":1,"sourceId":32,"targetId":10},{"weight":1,"sourceId":32,"targetId":9},{"weight":1,"sourceId":32,"targetId":28},{"weight":1,"sourceId":12,"targetId":31},{"weight":1,"sourceId":13,"targetId":33},{"weight":1,"sourceId":8,"targetId":33},{"weight":1,"sourceId":14,"targetId":33},{"weight":1,"sourceId":33,"targetId":27}]};*/
 var data = {vertices: [], edges:[]};

 /*function clear_data(data) {
   clone = Object.assign({}, data);
   clone.edges.forEach(function(edge) {
     edge.sourceId = edge.source.id;
     delete edge.source;
     edge.targetId = edge.target.id;
     delete edge.target;
   });
 }*/
 function newGraph() {
    if(activeButton) {
     activeButton.style.borderStyle = 'outset';
    }
    if(activeMode) {
     activeMode.deactivate();
    }
    data = {vertices:[], edges:[]};
    prepare_data(data);
    update();

    let nvertices = prompt("Number of boundary vertices");
    for(i=0; i<nvertices;i++) {
      data.vertices[i] = {
        x: radius*Math.sin(i*2*Math.PI/nvertices),
        y: radius*Math.cos(i*2*Math.PI/nvertices),
        id: i,
        type: "filled"
      };
    }
    maxVertexId = nvertices-1;
    prepare_data(data);
    update();
 }

 function exportData() {
   var d = {edges:[], vertices: data.vertices};

   data.edges.forEach(function(edge) {
   	let f = {
       weight : edge.weight,
     	sourceId : edge.source.id,
     	targetId : edge.target.id
     };
   	d.edges.push(f);
   });
   console.log(JSON.stringify(d));
    navigator.clipboard.writeText(JSON.stringify(d));
 }

function exportTikz() {
  let tikzString = `
\\documentclass{standalone}
\\usepackage{tikz}
\\tikzstyle{vertex}=[
	minimum size=0.15cm,
  inner sep=0pt,
  outer sep=0pt,
  circle,
  draw=black,
]
\\tikzstyle{filled}=[
	vertex,
	fill=black
]
\\tikzstyle{unfilled}=[
	vertex,
	fill=white
]
\\tikzstyle{blank}=[
	vertex,
	fill=white,
	draw=white
]

\\tikzstyle{hourglass}=[
	out=#1*20,
	in={#1*20+180},
	relative,
	looseness=1.5
]
\\begin{document}

\\begin{tikzpicture}
\\node [draw, circle, minimum size=${2*radius}cm, dashed] at (0,0) {};
  `;
  data.vertices.forEach(function(v) {
    tikzString += `\\node [${v.type}] (v${v.id}) at (${v.x.toFixed(2)},${v.y.toFixed(2)}) {};\n`;
  });

  data.edges.forEach(function(e) {
    let v_fromIdStr = "v"+e.source.id;
    let v_toIdStr = "v"+e.target.id;
    var hourglass_style = [0,0,1,1.5,2,2.5];
    if(e.weight == 1) {
      tikzString += `\\draw (${v_fromIdStr}) to (${v_toIdStr});\n`;
    } else {
      let hs = hourglass_style[hourglass_style.length-1];
      if (e.weight < hourglass_style.length) {
        hs = hourglass_style[e.weight];
      }
      for (var i=0; i<e.weight; i++) {
        tikzString += `\\draw[hourglass=${hs-i*2*hs/(e.weight-1)}] (${v_fromIdStr}) to (${v_toIdStr});\n`;
      }
      //tikzString += `\\draw[hourglass=1] (${v_fromIdStr}) to (${v_toIdStr});\n`;
      //tikzString += `\\draw[hourglass=-1] (${v_fromIdStr}) to (${v_toIdStr});\n`;
    }
  });
  tikzString += `
\\end{tikzpicture}
\\end{document}
  `;
  //document.getElementById('tikz').textContent = tikzString;
   navigator.clipboard.writeText(tikzString);
}

 function prepare_data(data) {
   data.edges.forEach(function(edge) {
     edge.source = data.vertices.filter(vertex => vertex.id == edge.sourceId)[0];
     edge.target = data.vertices.filter(vertex => vertex.id == edge.targetId)[0];
   });
 }

 function addOrRemove(array, value) {
     var index = array.indexOf(value);

     if (index === -1) {
         array.push(value);
     } else {
         array.splice(index, 1);
     }
 }


 var maxVertexId = 0;


var size = 600;
var body = d3.select("body");
var svg = d3.select("#paper-container")
 .append("svg")
 .attr("id", "paper")
 .attr("width", size)
 .attr("height", size);

var x = d3.scaleLinear().domain([-radius*1.1,radius*1.1]).range([0, size]);
var y = d3.scaleLinear().domain([-radius*1.1,radius*1.1]).range([size, 0]);

var selected = [];

var boundary_circle = svg.append("circle")
    .attr('id', 'boundary_circle')
    .attr('cx',x(0) )
    .attr('cy', y(0) )
    .attr('r',x(radius)-x(0));


var edges = svg.append("g").attr("id", "edges");
var vertices = svg.append("g").attr("id", "vertices");

function hourglassPath(edge) {
  var pos1_x = edge.source.x;
  var pos1_y = edge.source.y;
  var pos2_x = edge.target.x;
  var pos2_y = edge.target.y;
  var dx = pos2_x - pos1_x;
  var dy = pos2_y - pos1_y;

  var mid_x = (pos1_x+pos2_x)/2;
  var mid_y = (pos1_y+pos2_y)/2;
  var quater1_x = 0.75*pos1_x+0.25*pos2_x;
  var quater1_y = 0.75*pos1_y+0.25*pos2_y;
  var quater2_x = 0.25*pos1_x+0.75*pos2_x;
  var quater2_y = 0.25*pos1_y+0.75*pos2_y;
  var d = `M ${x(pos1_x)} ${y(pos1_y)} L ${x(pos2_x)} ${y(pos2_y)}`;

  var curveGenerator = d3.line()
    .curve(d3.curveNatural)
    .x(d=>x(d[0])).y(d=>y(d[1]));

  var d = "";

  for(var i=0; i<edge.weight; i++) {
    var factor = (-(edge.weight-1)/2+i);//*1/(Math.sqrt(dx*dx+dy*dy))*20;
    var points = [
      [pos1_x, pos1_y],
      [quater1_x+factor*dy/8, quater1_y-factor*dx/8],
      [mid_x, mid_y],
      [quater2_x-factor*dy/8, quater2_y+factor*dx/8],
      [pos2_x, pos2_y]
    ];

    d += curveGenerator(points);
  }


  return d;


  /*
  if degree % 2 == 1:
      H += line([pos1,pos2], color="black")

  if degree == 1:
      if edge_label is not None:
          H += text(edge_label,mid,background_color='white')
      return H
  V = pos2-pos1
  Vortho = matrix([[0,1],[-1,0]])*V
  quater1 = 0.75*pos1+0.25*pos2
  quater2 = 0.25*pos1+0.75*pos2
  for i in range(degree//2):
      factor = (i+1.0)/(degree//2)
      path1 = [[tuple(pos1),tuple(quater1+Vortho/8*factor),tuple(mid)],[tuple(quater2-Vortho/8*factor),tuple(pos2)]]
      path2 = [[tuple(pos1),tuple(quater1-Vortho/8*factor),tuple(mid)],[tuple(quater2+Vortho/8*factor),tuple(pos2)]]
      H += bezier_path(path1, color="black")+bezier_path(path2, color="black")
  if edge_label is not None:
      H += text(edge_label,mid,background_color='white')

  return H*/
}

 function update() {

// send array data to python!

   /*edges.selectAll(".edge").data(data.edges)
     .join("line")
     .attr("class", "edge")
     .attr("x1", d=>x(d.source.x))
     .attr("y1", d=>y(d.source.y))
     .attr("x2", d=>x(d.target.x))
     .attr("y2", d=>y(d.target.y));*/
     edges.selectAll(".edge").data(data.edges)
       .join("path")
       .attr("class", "edge")
       .attr("d", hourglassPath)
       .attr("fill", "none");
     /*.each(function(d,i) {
       var source = data.vertices.filter(vertex => vertex.id == d.sourceId)[0];
       var target = data.vertices.filter(vertex => vertex.id == d.targetId)[0];
       d3.select(this)
        //.attr("x1", source.x)
        .attr("y1", source.y)
        .attr("x2", target.x)
        .attr("y2", target.y);
     });*/



     vertices.selectAll(".vertex").data(data.vertices)
        .join(
          enter => enter
              .append("circle")
              .attr("class", "vertex")
              .classed("unfilled", d=>d.type=="unfilled")
              .classed("filled", d=>d.type=="filled")
              .attr("cx", function(d) {
                return x(d.x)
              })
              .attr("cy", function(d) {
                return y(d.y)
              })
              .attr("r", 4),
          update => update
          .classed("unfilled", d=>d.type=="unfilled")
          .classed("filled", d=>d.type=="filled")
        );


   /*vertices.selectAll(".vertex").data(data.vertices)
      .join("circle")
      .attr("class", "vertex")
      .classed("unfilled", d=>d.type=="unfilled")
      .classed("filled", d=>d.type=="filled")
      .attr("cx", function(d) {
        return d.x
      })
      .attr("cy", function(d) {
        return d.y
      })
      .attr("r", 4)
      .on("click", function(e) {
        d3.select(this).classed("selected", !d3.select(this).classed("selected"));
        addOrRemove(selected, this);
      });*/
 }

   //.call(drag);

   //svg.on('click', addVertex);



   function addEdge(weight) {
     var selection = d3.selectAll(selected);
     var selectedVertices = selection.data();
     /*if (selectedVertices.length < 2) {
       console.log("Select at least two vertices");
       return;
     }*/
     for(var i=0; i < selectedVertices.length-1; i++) {
       data.edges.push({source:selectedVertices[i], target:selectedVertices[i+1], weight:weight});
     }
     update();
   }


   //update();

</script>
<script src="code.js"></script>
</body>
</html>
