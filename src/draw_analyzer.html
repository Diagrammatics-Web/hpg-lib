<!DOCTYPE html>
<html>
<head>
  <script type="text/javascript" src="eel.js"></script>
  <script src="d3.js"></script>
  <script>
    // notify server to render app
    eel.update_server_status(true);
  </script>
  <link rel="stylesheet" href="styles.css">
</head>
<body>

<br>

<div id="import-export-btns">
  <button id="btn-off" onclick="end_session()">Save/Finish</button>
</div>

<div>
  <div id="paper-container"></div>
  <button id="btn-toggle_labels" onclick="toggleLabels()">Toggle vertex labels</button>
</div>

<br>

<div id="actions">
  <button id="btn-trip1" onclick="activateButton(this,'trip1')">Trip1</button>
  <button id="btn-trip2" onclick="activateButton(this,'trip2')">Trip2</button>
  <button id="btn-trip3" onclick="activateButton(this,'trip3')">Trip3</button>
  <button id="btn-edgetrips" onclick="activateButton(this,'edge_trips')">Trips through edge</button>
  <!--<button id="btn-faces" onclick="toggleFaces()">Toggle Faces</button>-->
  <button id="btn-faces" onclick="tutteLayout()">Compute Tutte layout</button>
  <button id="btn-faces" onclick="lloydLayout()">Apply Lloyd's algorithm</button>
  <button id="btn-cycle-face" onclick="activateButton(this, 'cycle_face')">Cycle face</button>
  <button id="btn-cycle-face" onclick="activateButton(this, 'square_move')">Square move</button>
  <button id="btn-cycle-face" onclick="activateButton(this, 'separation_labeling')">Separation Labeling</button>
</div>


<script>

// global state variables
const radius = 10;
var data = {vertices: [], edges:[], faces:[]};
var boundaryVertices = [];
var showLabels = false;
var edgePaths = [];
var showFaces = false;
var showEdgeLabels = false;


/*
 *  Initialize Canvas
 */
var maxVertexId = 0;
var size = 800;
var body = d3.select("body");
var x = d3.scaleLinear().domain([-radius*1.1,radius*1.1]).range([0, size]);
var y = d3.scaleLinear().domain([-radius*1.1,radius*1.1]).range([size, 0]);

var selectedIds = []; // ids of selected vertices
var selected = []; // selected vertices
var highlightedPath = null;

// init graph canvas
var svg = d3.select("#paper-container")
 .append("svg")
 .attr("id", "paper")
 .attr("width", size)
 .attr("height", size);

var maingroup = svg.append("g");

// init boundary circle
var boundary_circle = maingroup.append("circle")
    .attr('id', 'boundary_circle')
    .attr('cx',x(0) )
    .attr('cy', y(0) )
    .attr('r',x(radius)-x(0));

// init groups for edges and vertices
var faces = maingroup.append("g").attr("id", "faces");
var edges = maingroup.append("g").attr("id", "edges");
var vertices = maingroup.append("g").attr("id", "vertices");

var paths = maingroup.append("g").attr("id", "edgePaths");


svg.call(d3.zoom()
    .translateExtent([[0, 0], [size, size]])
    .scaleExtent([1, 8])
    .on("zoom", zoomed));

function zoomed(e) {
  //edges.attr("transform", d => `translate(${transform.apply(d)})`);
  maingroup.attr("transform", d => e.transform);
  //edges.attr("transform", d => e.transform);
}


// get initial graph from backend
eel.get_graph()((g) => {
  data = g;
  preprocess_data();
  update();
});


function tutteLayout() {
  eel.tutte_layout()((g) => {
    data = g;
    preprocess_data();
    update();
  });
}


function lloydLayout() {
  eel.lloyd_layout()((g) => {
    data = g;
    preprocess_data();
    update();
  });
}

// return curve string for D3 to render edge
function hourglassPath(edge, shift=0) {
  const offset = 0.15;

  var pos1_x = edge.source.x;
  var pos1_y = edge.source.y;
  var pos2_x = edge.target.x;
  var pos2_y = edge.target.y;

  theta = Math.atan2((pos2_y - pos1_y),(pos2_x - pos1_x));
  pos1_x -= shift*offset*Math.sin(theta);
  pos2_x -= shift*offset*Math.sin(theta);
  pos1_y += shift*offset*Math.cos(theta);
  pos2_y += shift*offset*Math.cos(theta);


  var dx = pos2_x - pos1_x;
  var dy = pos2_y - pos1_y;
  var mid_x = (pos1_x+pos2_x)/2;
  var mid_y = (pos1_y+pos2_y)/2;
  var quater1_x = 0.75*pos1_x+0.25*pos2_x;
  var quater1_y = 0.75*pos1_y+0.25*pos2_y;
  var quater2_x = 0.25*pos1_x+0.75*pos2_x;
  var quater2_y = 0.25*pos1_y+0.75*pos2_y;
  var d = `M ${x(pos1_x)} ${y(pos1_y)} L ${x(pos2_x)} ${y(pos2_y)}`;

  var curveGenerator = d3.line()
    .curve(d3.curveNatural)
    .x(d=>x(d[0])).y(d=>y(d[1]));

  var d = "";

  var factor = (-(edge.multiplicity-1)/2+edge.index);
  var points = [
    [pos1_x, pos1_y],
    [quater1_x+factor*dy/8, quater1_y-factor*dx/8],
    [mid_x, mid_y],
    [quater2_x-factor*dy/8, quater2_y+factor*dx/8],
    [pos2_x, pos2_y]
  ];

  d += curveGenerator(points);

  return d;
}

/*
 *  Fns for generating polygon hull html elements for boundary shapes
 */
function toggleFaces(arg=null) {
  // define helper functions
  // one for activating faces
  function activateFaces() {
    // if faces already exist, remove them
    d3.selectAll(".face").remove();

    faces.selectAll(".face-label")
      .data(data.faces)
      .join("text")
      .attr("class", "face-label")
      .attr("x", d => x(d.center.x))
      .attr("y", d => y(d.center.y))
      .attr("height", 10)
      .attr("width", 10)
      .text(d => d.id);

    // draw lines for each face
    let polygon = d3.line().curve(d3.curveLinearClosed);

    // add polygons to svg
    // generate pseudodata for each face
  }
  // and one for deactivating faces
  function deactivateFaces() {
    d3.selectAll(".face").remove();
    d3.selectAll(".face-label").remove();
  }

  // if arg is null, toggle faces
  if (arg == null) {
    showFaces = !showFaces;
  } else {
    showFaces = arg;
  }

  if (showFaces) {
    activateFaces();
  } else {
    deactivateFaces();
  }
}









// update graph svg based on data updates
function update() {
  if (data == null) {
    console.log("data is null")
    data = {vertices:[], edges:[], faces:[]};
  }
  activeObjects = svg.selectAll(".active")



  // update path html element for each edge type
  // this generates pseudo-edges for each component of an hourglass edge


  /*paths.selectAll(".edgePath").data(
    function() {
      var edgs = [];
      edgePathsCnt = {};
      for(i=0; i<edgePaths.length; i++)  {
        path = edgePaths[i]
        console.log(path);
        for(j=0; j<path.length; j++){
          if(edgePathsCnt[path[j]] == undefined) {
            edgePathsCnt[path[j]] = 1;
          }
          edgs.push({edge:path[j], pathIdx:i, shift:edgePathsCnt[path[j]]});
          edgePathsCnt[path[j]]++;
        }
      }
      console.log(edgs);
      return edgs;

    })
    .join("path")
    .attr("class", "edgePath")
    .attr("d", (d) => {
      return hourglassPath(data.edges.filter(e => e.id == d.edge)[0], d.shift);
    })
    .attr("stroke", d=> d3.schemeCategory10[d.pathIdx])
    .attr("stroke-width",2)
    .attr("fill", "none");*/

    //d3.selectAll(".edgePath").remove();
    paths.selectAll(".edgePath").data(
      function() {
        var edgs = [];
        edgePathsCnt = {};
        for(i=0; i<edgePaths.length; i++)  {
          path = edgePaths[i]
          for(j=0; j<path.length; j++){
            if(edgePathsCnt[path[j]] == undefined) {
              edgePathsCnt[path[j]] = 1;
            }
            edgs.push({edge:path[j], pathIdx:i, shift:edgePathsCnt[path[j]]});
            edgePathsCnt[path[j]]++;
          }
        }
        for(i=0; i<edgs.length; i++) {
          edgs[i].total = edgePathsCnt[edgs[i].edge]-1;
        }
        return edgs;

      })
      .join("circle")
      .attr("class", "edgePath")
      .attr("cx", (d) => {
        var pnode = d3.select("#"+d.edge).node();
        var plen = pnode.getTotalLength()/2;
        var pos = plen+(d.shift-0.5)*plen/d.total;
        d.point = pnode.getPointAtLength(pos);
        console.log(d.point.x);
        return d.point.x;
      })
      .attr("cy", (d) => d.point.y)
      .attr("r", 2)
      .attr("stroke", d=> d3.schemeCategory10[d.pathIdx])
      .attr("fill", d=> d3.schemeCategory10[d.pathIdx])
      .attr("stroke-width",2)
      .on("mousemove", function(e,d) {
        highlightedPath = d.pathIdx;
        update();
      });

    function hp(edge) {
      var path = d3.path();
      var start = edge.source;
      var end = edge.target;
      var v = {x: (end.x-start.x)/4, y: (end.y-start.y)/4};
      var factor = (-(edge.multiplicity-1)/2+edge.index);
      var phi = 40*Math.PI/180;
      var looseness = 1.5;
      var dir = {x:v.x*Math.cos(factor*phi)+v.y*Math.sin(factor*phi),y:-v.x*Math.sin(factor*phi)+v.y*Math.cos(factor*phi)};

      path.moveTo(x(start.x), y(start.y));

  		path.bezierCurveTo(x(start.x+looseness*dir.x),
                         y(start.y+looseness*dir.y),
                         x(end.x-looseness*dir.x),
                         y(end.y-looseness*dir.y),
                         x(end.x),
                         y(end.y));
      //console.log(path);
      return path;
    }

  edges.selectAll(".edge").data(data.edges)
    .join("path")
    .attr("class", "edge")
    .attr("id", d=>d.id)
    .attr("d", d=>hp(d))
    .attr("fill", "none")
    .attr("stroke-width",d => {
      if(highlightedPath != null && edgePaths[highlightedPath].indexOf(d.id) > -1) {
        return 4;
      }
      return 2;
    })
    .attr("stroke", d => {
      if(highlightedPath != null && edgePaths[highlightedPath].indexOf(d.id) > -1) {
        return d3.schemeCategory10[highlightedPath];
      }
      return "black";
    });


  // add circle html element for each vertex
  vertices.selectAll(".vertex").data(data.vertices)
    .join("circle")
    .attr("class", "vertex")
    .classed("unfilled", d=>!d.filled)
    .classed("filled", d=>d.filled)
    .attr("cx", function(d) {
      return x(d.x)
    })
    .attr("cy", function(d) {
      return y(d.y)
    })
    .attr("r", 4)
    .classed("selected", d => {
      return selectedIds.indexOf(d.id) > -1;
    });

  // add labels if option selected
  vertices.selectAll(".vertex-label").data(data.vertices)
    .join("text")
    .attr("class", "vertex-label")
    .attr("x", function(d) {
      return x(d.x-0.3)
    })
    .attr("y", function(d) {
      return y(d.y+0.3)
    })
    .text(function(d) {
      if (!showLabels) {
        return "";
      }
      return d.id;
    });


    edges.selectAll(".hourglass-label-background").data(data.edges)
    .join("circle")
    .attr("class", "hourglass-label-background")
    .attr("cx", function(d) {
      var pnode = d3.select("#"+d.id).node();
      var plen = pnode.getTotalLength();
      var pos = 0.25;
      d.label_pos = pnode.getPointAtLength(pos*plen);
      return d.label_pos.x;
    })
    .attr("cy", function(d) {
      return d.label_pos.y;
    })
    .attr("r", 6)
    .attr("fill", function(d) {
      if (!showEdgeLabels) {
        return "none";
        //return d.multiplicity;
      }
      return "white";
    });

    edges.selectAll(".hourglass-label").data(data.edges)
    .join("text")
    .attr("class", "hourglass-label")
    .attr("x", function(d) {
      var pnode = d3.select("#"+d.id).node();
      var plen = pnode.getTotalLength();
      var pos = 0.25;
      d.label_pos = pnode.getPointAtLength(pos*plen);
      return d.label_pos.x;
    })
    .attr("y", function(d) {
      return d.label_pos.y;
    })
    .text(function(d) {
      if (!showEdgeLabels) {
        return "";
        //return d.multiplicity;
      }
      return d.label;
    });



    faces.selectAll(".face")
      .data(data.faces)
      .join("path")
      // pseudo data for each face
      .attr("d", d => {
        let polygon = d3.line().curve(d3.curveLinearClosed);

        // preprocess data
        let pts = [];
        //for (v of d) {pts.push([x(v[1]), y(v[2])]);}
        const polygon_hull = polygon(d.vertices.map(v => [x(v.x), y(v.y)]));

        return polygon_hull;
      })
      /*.on("click", (e, d) => {
        // select all updatevertices in face
        //let face_vertices = d.map(v => v[0]);

        // depending on mode, perform different move
        if (moveMode == false) {
          return;
        }
        else if (moveMode === 'cycle_face') {
          cycleFace(d.id, e.shiftKey);
        } else if (moveMode === 'square_move') {
          squareMove(d.id);
        }
      })*/
      .attr("class", "face");

      activeObjects.classed("active", true);

}

/*
 *  Backend Frontend Communication fns
 */
// store graph data to python and close session
function end_session() {
  //eel.update_graph_from_editor(data_compressed());
  // disable all interactions
  d3.select("*").style("pointer-events", "none");
  eel.update_server_status(false);
}

// bring graph to frontend and preprocess data
function preprocess_data() {
  maxVertexId = Math.max(...data.vertices.map(v => v.id)) + 1;

  // add references to source and target vertices
  data.edges.forEach(function(edge, i) {
    edge.source = data.vertices.filter(vertex => vertex.id == edge.sourceId)[0];
    edge.target = data.vertices.filter(vertex => vertex.id == edge.targetId)[0];
    //edge.id = i;
  });

  data.faces.forEach(function(face, i) {
    face.vertices = face.vertexIds.map(id => data.vertices.filter(vertex => vertex.id == id)[0]);
    face.center = {};
    face.center.x = d3.mean(face.vertices, vertex => vertex.x);
    face.center.y = d3.mean(face.vertices, vertex => vertex.y);
  });
}


</script>
<script src="controller_analyzer.js"></script>
</body>
</html>
