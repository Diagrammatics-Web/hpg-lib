<!DOCTYPE html>
<html>
<head>
  <script type="text/javascript" src="eel.js"></script>
  <script src="d3.js"></script>
  <script>
    // notify server to render app
    eel.update_server_status(true);
  </script>
  <link rel="stylesheet" href="styles.css">
</head>
<body>

<textarea id= "jsonData" style= "border-width: medium;"></textarea>
<button id="btn-import" onclick="importJson()">Import json data</button>
<br>

<button id="btn-new" onclick="newGraph()">New</button>
<button id="btn-off" onclick="end_session()">Save/Finish</button>
<button id="btn-export" onclick="exportData()">Export data as json</button>
<button id="btn-tikz" onclick="exportTikz()">Export tikz to clipboard</button>
<br>

<div id="paper-container"></div>

<br>
<button id="btn-trip1" onclick="activateButton(this,'trip1')">Trip1</button>
<button id="btn-trip2" onclick="activateButton(this,'trip2')">Trip2</button>
<button id="btn-trip3" onclick="activateButton(this,'trip3')">Trip3</button>

<br>
<button id="btn-deselect" onclick="deselect()">Deselect all</button>
<button id="btn-move" onclick="activateButton(this,'move')">Move</button>
<button id="btn-place_filled" onclick="activateButton(this,'place_filled')">Place filled vertex</button>
<button id="btn-place_unfilled" onclick="activateButton(this,'place_unfilled')">Place unfilled vertex</button>
<button id="btn-toggle_color" onclick="activateButton(this,'toggle_color')">Toggle vertex color</button>
<button id="btn-add_edge" onclick="activateButton(this,'place_edge')">Add edge</button>
<button id="btn-add_hourglass" onclick="activateButton(this,'place_hourglass')">Add hourglass</button>
<button id="btn-add_khourglass" onclick="activateButton(this,'place_khourglass')">Add k-hourglass</button>
<button id="btn-toggle_labels" onclick="activateButton(this,'toggle_labels')">Toggle vertex labels</button>
<!--<textarea id= "tikz" style= "border-width: medium;"></textarea>-->



<script>

// global state variables
const radius = 10;
var data = {vertices: [], edges:[]};
var boundaryVertices = [];
var edgePath = [];
var showLabels = false;


/* 
 *  Initialize Canvas
 */
var maxVertexId = 0;
var size = 600;
var body = d3.select("body");
var x = d3.scaleLinear().domain([-radius*1.1,radius*1.1]).range([0, size]);
var y = d3.scaleLinear().domain([-radius*1.1,radius*1.1]).range([size, 0]);

var selected = [];

// init graph canvas
var svg = d3.select("#paper-container")
 .append("svg")
 .attr("id", "paper")
 .attr("width", size)
 .attr("height", size);

// init boundary circcle
var boundary_circle = svg.append("circle")
    .attr('id', 'boundary_circle')
    .attr('cx',x(0) )
    .attr('cy', y(0) )
    .attr('r',x(radius)-x(0));

// init groups for edges and vertices
var edges = svg.append("g").attr("id", "edges");
var vertices = svg.append("g").attr("id", "vertices");


// get initial graph from backend
eel.get_graph()((g) => {
  data = g;
  preprocess_data();
  update();
});

// create new graph, prompt for number of vertices
function newGraph() {
  if(activeButton) {
    activeButton.style.borderStyle = 'outset';
  }
  if(activeMode) {
    activeMode.deactivate();
  }
  data = {vertices:[], edges:[]};
  update();

  let nvertices = prompt("Number of boundary vertices");
  for(i=0; i<nvertices;i++) {
    data.vertices[i] = {
      x: radius*Math.sin(i*2*Math.PI/nvertices),
      y: radius*Math.cos(i*2*Math.PI/nvertices),
      id: i,
      type: "filled"
    };
  }

  // send new graph to python
  eel.import_data(data)((d) => {
    data = d;
    preprocess_data();
    
    // FIXME: need to do the following
    // 1. update boundary vertices

    update();
  });
}


// return curve string for D3 to render edge
function hourglassPath(edge, hourglass_idx) {
  var pos1_x = edge.source.x;
  var pos1_y = edge.source.y;
  var pos2_x = edge.target.x;
  var pos2_y = edge.target.y;
  var dx = pos2_x - pos1_x;
  var dy = pos2_y - pos1_y;
  var mid_x = (pos1_x+pos2_x)/2;
  var mid_y = (pos1_y+pos2_y)/2;
  var quater1_x = 0.75*pos1_x+0.25*pos2_x;
  var quater1_y = 0.75*pos1_y+0.25*pos2_y;
  var quater2_x = 0.25*pos1_x+0.75*pos2_x;
  var quater2_y = 0.25*pos1_y+0.75*pos2_y;
  var d = `M ${x(pos1_x)} ${y(pos1_y)} L ${x(pos2_x)} ${y(pos2_y)}`;

  var curveGenerator = d3.line()
    .curve(d3.curveNatural)
    .x(d=>x(d[0])).y(d=>y(d[1]));

  var d = "";

  var factor = (-(edge.weight-1)/2+hourglass_idx);
  var points = [
    [pos1_x, pos1_y],
    [quater1_x+factor*dy/8, quater1_y-factor*dx/8],
    [mid_x, mid_y],
    [quater2_x-factor*dy/8, quater2_y+factor*dx/8],
    [pos2_x, pos2_y]
  ];

  d += curveGenerator(points);

  return d;
}

// update graph svg based on data updates
function update() {
  // make sure data is valid format
  if (data == null) {
    console.log("data is null")
    data = {vertices:[], edges:[]};
  }

  // update path html element for each edge type
  // this generates pseudo-edges for each component of an hourglass edge
  edges.selectAll(".edge")
    .data(() => {
      var edgs = [];
      for (e of data.edges) {
        for (var i=0; i<e.weight; i++) {
          edgs.push({edge:e, hourglass_idx:i});
        }
      }
      return edgs;
    })
    .join("path")
    .attr("id", d=>"e"+d.edge.id)
    .attr("class", "edge")
    .attr("d", (d) => hourglassPath(d.edge, d.hourglass_idx))
    .attr("fill", "none")
    // color edges if in edge path
    .classed("path", (d) => {
      var idx = edgePath.indexOf(JSON.stringify([d.edge.id, d.hourglass_idx]));
      return (idx > -1);
    });

  // add circle html element for each vertex
  vertices.selectAll(".vertex").data(data.vertices)
    .join(
      (enter) => 
        enter
          .append("circle")
          .attr("class", "vertex")
          .classed("unfilled", d=>d.type=="unfilled")
          .classed("filled", d=>d.type=="filled")
          .attr("cx", function(d) {
            return x(d.x)
          })
          .attr("cy", function(d) {
            return y(d.y)
          })
          .attr("r", 4)
      ,
      update => update
        .classed("unfilled", d=>d.type=="unfilled")
        .classed("filled", d=>d.type=="filled")
    );

  // add labels if option selected
  if (showLabels) {
    vertices.selectAll(".vertex-label").data(data.vertices)
      .join(
        (enter) => 
          enter
            .append("text")
            .attr("class", "vertex-label")
            .attr("x", function(d) {
              return x(d.x-0.3)
            })
            .attr("y", function(d) {
              return y(d.y+0.3)
            })
            .text(function(d) {
              return d.id
            })
      );
  }
}

// add edges to graph based on selected vertices
function addEdge(weight) {
  var selection = d3.selectAll(selected);
  console.log(selection)
  var selectedVertices = selection.data();
  for(var i=0; i < selectedVertices.length-1; i++) {
    data.edges.push({
      sourceId: selectedVertices[i].id, 
      targetId: selectedVertices[i+1].id, 
      weight: weight
    });
  }

  // FIXME: improve method for incremental updates
  eel.import_data(data_compressed())((d) => {
    data = d;
    preprocess_data();
    update();
  });
}



/* 
 *  Graph Import/Export fns
 */
// export graph data to JSON to clipboard
function exportData() {
  eel.get_graph()((d) => {
    navigator.clipboard.writeText(JSON.stringify(d));
  });
}

// export LaTeX TikZ to clipboard
function export_tikz() {
  eel.get_tikz()((tikzString) => {
    navigator.clipboard.writeText(tikzString);
  })
}
  
// import graph data from json
function importJson() {
  boundaryVertices = [];
  edgePath = [];
  data = {vertices:[], edges:[]};
  update();
  data = JSON.parse(document.getElementById("jsonData").value);

  // save to backend
  eel.import_data(data_compressed())((d) => {
    console.log("imported graph to backend");
    data = d;
    preprocess_data();
    update();
    console.log("data retrieved from backend");
  });
}


/* 
 *  Backend Frontend Communication fns
 */
// store graph data to python and close session
function end_session() {
  eel.import_data(data_compressed());
  eel.update_server_status(false);
}

// bring graph to frontend and preprocess data
function preprocess_data() {
  maxVertexId = Math.max(...data.vertices.map(v => v.id)) + 1;

  // add references to source and target vertices
  data.edges.forEach(function(edge, i) {
    edge.source = data.vertices.filter(vertex => vertex.id == edge.sourceId)[0];
    edge.target = data.vertices.filter(vertex => vertex.id == edge.targetId)[0];
    edge.id = i;
  });
}

// convert graph data to exportable object
function data_compressed() {
  var d = {edges:[], vertices: []};

  // add edge info
  data.edges.forEach(function(edge) {
    if (edge.weight == 3) {
      console.log("edge weight 3");
      // FIXME: for some reason, backend is unable to read edge weight 3
    }
    let f = {
      weight : edge.weight,
      sourceId : edge.sourceId,
      targetId : edge.targetId
    };
    d.edges.push(f);
  });

  // add vertex info
  data.vertices.forEach(function(vertex) {
    let f = {
        x : vertex.x,
        y : vertex.y,
        id : vertex.id,
        type : vertex.type
      };
    d.vertices.push(f);
  });

  return d;
}


</script>
<script src="controller.js"></script>
</body>
</html>
