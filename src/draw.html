<!DOCTYPE html>
<html>
<head>
  <script type="text/javascript" src="eel.js"></script>
  <script src="d3.js"></script>
  <script>
    // notify server to render app
    eel.update_server_status(true);
  </script>
  <link rel="stylesheet" href="styles.css">
</head>
<body>

<textarea id= "jsonData" style= "border-width: medium;"></textarea>
<button id="btn-import" onclick="importData()">Import json data</button>
<br>

<button id="btn-new" onclick="newGraph()">New</button>
<button id="btn-off" onclick="end_session()">Save/Finish</button>
<button id="btn-export" onclick="exportData()">Export data as json</button>
<button id="btn-tikz" onclick="exportTikz()">Export tikz to clipboard</button>
<br>

<div id="paper-container"></div>

<br>
<button id="btn-trip1" onclick="activateButton(this,'trip1')">Trip1</button>
<button id="btn-trip2" onclick="activateButton(this,'trip2')">Trip2</button>
<button id="btn-trip3" onclick="activateButton(this,'trip3')">Trip3</button>

<br>
<button id="btn-deselect" onclick="deselect()">Deselect all</button>
<button id="btn-move" onclick="activateButton(this,'move')">Move</button>
<button id="btn-place_filled" onclick="activateButton(this,'place_filled')">Place filled vertex</button>
<button id="btn-place_unfilled" onclick="activateButton(this,'place_unfilled')">Place unfilled vertex</button>
<button id="btn-toggle_color" onclick="activateButton(this,'toggle_color')">Toggle vertex color</button>
<button id="btn-add_edge" onclick="activateButton(this,'place_edge')">Add edge</button>
<button id="btn-add_hourglass" onclick="activateButton(this,'place_hourglass')">Add hourglass</button>
<button id="btn-add_khourglass" onclick="activateButton(this,'place_khourglass')">Add k-hourglass</button>
<!--<textarea id= "tikz" style= "border-width: medium;"></textarea>-->



<script>
const radius = 10;
// global state variables
var data = {vertices: [], edges:[]};
var boundaryVertices = [];
var edgePath = [];
var showLabels = true;

// fill in data with constructor data on python side
eel.get_graph()((g) => {
  data = g;
  // populate data with edge information
  prepare_data(data);
  // update canvas
  update();
});

// prepare edge data in data object, adding mhe info for hourglass edges
// TODO: need to alter mhe prep to account for multiple edges between vertices
function prepare_data(data) {
  data.vertices.forEach(function(vertex) {
    vertex.multiHalfEdges = [];
  });

  // equip each vertex with ordered list of edges
  data.edges.forEach(function(edge, i) {
    edge.source = data.vertices.filter(vertex => vertex.id == edge.sourceId)[0];
    edge.target = data.vertices.filter(vertex => vertex.id == edge.targetId)[0];
    edge.id = i;
    var mhe1 = {
      edge: edge,
      source: edge.source,
      target: edge.target,
      weight: edge.weight,
      twin: "",
      prev: "",
      next: "",
      halfEdges: []
    };
    edge.source.multiHalfEdges.push(mhe1);
    var mhe2 = {
      edge: edge,
      source: edge.target,
      target: edge.source,
      weight: edge.weight,
      twin: mhe1,
      prev: "",
      next: "",
      halfEdges: []
    };
    mhe1.twin = mhe2;
    edge.target.multiHalfEdges.push(mhe2);

    // add halfEdges to each multiHalfEdge object, inherent ordering
    for(var i=0; i<edge.weight; i++) {
      var he1 = {
        multiEdge: mhe1,
        twin: "",
        prev: "",
        next: "",
        heId: i // also used as hourglass_idx
      }
      mhe1.halfEdges.push(he1);
      var he2 = {
        multiEdge: mhe2,
        twin: he1,
        prev: "",
        next: "",
        heId: i // also used as hourglass_idx
      }
      mhe2.halfEdges.push(he2);
      he1.twin = he2;
    }
  });

  data.vertices.forEach(function(vertex) {
    // sort based on angle from vertex
    vertex.multiHalfEdges.sort(function(a,b) {
      return Math.atan2(a.target.y-vertex.y, a.target.x-vertex.x) - Math.atan2(b.target.y-vertex.y, b.target.x-vertex.x);
    });

    // TODO: double check this after looking at activateTrip logic
    // TODO: need to sort halfEdges in each mhe based on "weight index"
    let nedges = vertex.multiHalfEdges.length;
    if (nedges <= 1) {
      boundaryVertices.push(vertex);
      if(nedges == 1) vertex.multiHalfEdges[0].id=0;
    } else {
      for(var i=0; i<nedges; i++) {
        var mhe = vertex.multiHalfEdges[i];
        mhe.next = vertex.multiHalfEdges[(i+1)%nedges];
        mhe.prev = vertex.multiHalfEdges[(nedges+i-1)%nedges];
        mhe.id = i;

        //set prev and next for halfEdges in bundle
        // counterclockwise ordering
        // TODO: need to fix how we are ordering half edges
        for(var j=0; j<mhe.weight; j++) {
          if(j<mhe.weight-1) {
            mhe.halfEdges[j].prev = mhe.halfEdges[j+1];
          } else {
            mhe.halfEdges[j].prev = mhe.prev.halfEdges[0];
          }
          if(j>0) {
            mhe.halfEdges[j].next = mhe.halfEdges[j-1];
          } else {
            mhe.halfEdges[j].next = mhe.next.halfEdges[mhe.next.weight-1];
          }
        }
      }
    }

  });
}

// create new graph, prompt for number of vertices
function newGraph() {
  if(activeButton) {
    activeButton.style.borderStyle = 'outset';
  }
  if(activeMode) {
    activeMode.deactivate();
  }
  data = {vertices:[], edges:[]};
  update_edge_data(data);
  update();

  let nvertices = prompt("Number of boundary vertices");
  for(i=0; i<nvertices;i++) {
    data.vertices[i] = {
      x: radius*Math.sin(i*2*Math.PI/nvertices),
      y: radius*Math.cos(i*2*Math.PI/nvertices),
      id: i,
      type: "filled"
    };
  }
  maxVertexId = nvertices-1;
  update_edge_data(data);
  update();

  // send new graph to python
  eel.print_from_js(data);
}

// point each edge to a source/target vertices based on Id data
function update_edge_data(data) {
  data.edges.forEach(function(edge) {
    edge.source = data.vertices.filter(vertex => vertex.id == edge.sourceId)[0];
    edge.target = data.vertices.filter(vertex => vertex.id == edge.targetId)[0];
  });
}

// helper fn: add value if missing, remove if present
function addOrRemove(array, value) {
  var index = array.indexOf(value);

  if (index === -1) {
      array.push(value);
  } else {
      array.splice(index, 1);
  }
}


var maxVertexId = 0;
var size = 600;
var body = d3.select("body");
var x = d3.scaleLinear().domain([-radius*1.1,radius*1.1]).range([0, size]);
var y = d3.scaleLinear().domain([-radius*1.1,radius*1.1]).range([size, 0]);

var selected = [];

// init graph canvas
var svg = d3.select("#paper-container")
 .append("svg")
 .attr("id", "paper")
 .attr("width", size)
 .attr("height", size);

// init boundary circcle
var boundary_circle = svg.append("circle")
    .attr('id', 'boundary_circle')
    .attr('cx',x(0) )
    .attr('cy', y(0) )
    .attr('r',x(radius)-x(0));

// init groups for edges and vertices
var edges = svg.append("g").attr("id", "edges");
var vertices = svg.append("g").attr("id", "vertices");

// return curve string for D3 to render edge
function hourglassPath(edge, hourglass_idx) {
  var pos1_x = edge.source.x;
  var pos1_y = edge.source.y;
  var pos2_x = edge.target.x;
  var pos2_y = edge.target.y;
  var dx = pos2_x - pos1_x;
  var dy = pos2_y - pos1_y;
  var mid_x = (pos1_x+pos2_x)/2;
  var mid_y = (pos1_y+pos2_y)/2;
  var quater1_x = 0.75*pos1_x+0.25*pos2_x;
  var quater1_y = 0.75*pos1_y+0.25*pos2_y;
  var quater2_x = 0.25*pos1_x+0.75*pos2_x;
  var quater2_y = 0.25*pos1_y+0.75*pos2_y;
  var d = `M ${x(pos1_x)} ${y(pos1_y)} L ${x(pos2_x)} ${y(pos2_y)}`;

  var curveGenerator = d3.line()
    .curve(d3.curveNatural)
    .x(d=>x(d[0])).y(d=>y(d[1]));

  var d = "";

  var factor = (-(edge.weight-1)/2+hourglass_idx);
  var points = [
    [pos1_x, pos1_y],
    [quater1_x+factor*dy/8, quater1_y-factor*dx/8],
    [mid_x, mid_y],
    [quater2_x-factor*dy/8, quater2_y+factor*dx/8],
    [pos2_x, pos2_y]
  ];

  d += curveGenerator(points);

  return d;
}

// update graph svg based on data updates
function update() {
  // make sure data is valid format
  if (data == null) {
    console.log("data is null")
    data = {vertices:[], edges:[]};
  }

  // update path html element for each edge type
  // FIXME: not huge fan of this, but it works
  // this generates pseudo-edges for each component of an hourglass edge
  edges.selectAll(".edge")
    .data(() => {
      var edgs = [];
      for (e of data.edges) {
        for (var i=0; i<e.weight; i++) {
          edgs.push({edge:e, hourglass_idx:i});
        }
      }
      return edgs;
    })
    .join("path")
    .attr("id", d=>"e"+d.edge.id)
    .attr("class", "edge")
    .attr("d", (d) => hourglassPath(d.edge, d.hourglass_idx))
    .attr("fill", "none")
    // color edges if in edge path
    .classed("path", (d) => {
      var idx = edgePath.indexOf(JSON.stringify([d.edge.id, d.hourglass_idx]));
      return (idx > -1);
    });

  // update circle html element for each vertex
  vertices.selectAll(".vertex").data(data.vertices)
    .join(
      (enter) => 
        enter
          .append("circle")
          .attr("class", "vertex")
          .classed("unfilled", d=>d.type=="unfilled")
          .classed("filled", d=>d.type=="filled")
          .attr("cx", function(d) {
            return x(d.x)
          })
          .attr("cy", function(d) {
            return y(d.y)
          })
          .attr("r", 4)
      ,
      update => update
        .classed("unfilled", d=>d.type=="unfilled")
        .classed("filled", d=>d.type=="filled")
    );

  // add labels to vertices for trip perm debugging
  if (showLabels) {
    vertices.selectAll(".vertex-label").data(data.vertices)
      .join(
        (enter) => 
          enter
            .append("text")
            .attr("class", "vertex-label")
            .attr("x", function(d) {
              return x(d.x-0.3)
            })
            .attr("y", function(d) {
              return y(d.y+0.3)
            })
            .text(function(d) {
              return d.id
            })
      );
  }
}

// add edges to graph based on selected vertices
function addEdge(weight) {
  var selection = d3.selectAll(selected);
  console.log(selection)
  var selectedVertices = selection.data();
  for(var i=0; i < selectedVertices.length-1; i++) {
    data.edges.push({
    source:selectedVertices[i], 
    target:selectedVertices[i+1], 
    weight:weight
    });
  }

  // update canvas
  update();
}



/* 
 *  Graph Import/Export fns
 */

// convert graph data to recyclable format
// return value is convertable to JSON
function export_graph() {
  var d = {edges:[], vertices: []};

  // add edge info
  data.edges.forEach(function(edge) {
  let f = {
      weight : edge.weight,
    sourceId : edge.source.id,
    targetId : edge.target.id
    };
  d.edges.push(f);
  });

  // add vertex info
  data.vertices.forEach(function(vertex) {
    let f = {
        x : vertex.x,
        y : vertex.y,
        id : vertex.id,
        type : vertex.type
      };
    d.vertices.push(f);
  });

  return d;
}

// export graph data to JSON to clipboard
function exportData() {
  let d = export_graph();
  console.log(JSON.stringify(d));
  navigator.clipboard.writeText(JSON.stringify(d));
}

function defaultTikzString() {
  str = `
\\documentclass{standalone}
\\usepackage{tikz}
\\tikzstyle{vertex}=[
  minimum size=0.15cm,
  inner sep=0pt,
  outer sep=0pt,
  circle,
  draw=black,
]
\\tikzstyle{filled}=[
  vertex,
  fill=black
]
\\tikzstyle{unfilled}=[
  vertex,
  fill=white
]
\\tikzstyle{blank}=[
  vertex,
  fill=white,
  draw=white
]

\\tikzstyle{hourglass}=[
  out=#1*20,
  in={#1*20+180},
  relative,
  looseness=1.5
]
\\begin{document}

\\begin{tikzpicture}
\\node [draw, circle, minimum size=${2*radius}cm, dashed] at (0,0) {};
  `;

  return str;
}

// export LaTeX TikZ to clipboard
function exportTikz() {
  let tikzString = defaultTikzString();
  data.vertices.forEach(function(v) {
    tikzString += `\\node [${v.type}] (v${v.id}) at (${v.x.toFixed(2)},${v.y.toFixed(2)}) {};\n`;
  });

  data.edges.forEach(function(e) {
    let v_fromIdStr = "v"+e.source.id;
    let v_toIdStr = "v"+e.target.id;
    var hourglass_style = [0,0,1,1.5,2,2.5];
    if(e.weight == 1) {
      tikzString += `\\draw (${v_fromIdStr}) to (${v_toIdStr});\n`;
    } else {
      let hs = hourglass_style[hourglass_style.length-1];
      if (e.weight < hourglass_style.length) {
        hs = hourglass_style[e.weight];
      }
      for (var i=0; i<e.weight; i++) {
        tikzString += `\\draw[hourglass=${hs-i*2*hs/(e.weight-1)}] (${v_fromIdStr}) to (${v_toIdStr});\n`;
      }
      //tikzString += `\\draw[hourglass=1] (${v_fromIdStr}) to (${v_toIdStr});\n`;
      //tikzString += `\\draw[hourglass=-1] (${v_fromIdStr}) to (${v_toIdStr});\n`;
    }
  });
  tikzString += `
\\end{tikzpicture}
\\end{document}
  `;
  //document.getElementById('tikz').textContent = tikzString;
  navigator.clipboard.writeText(tikzString);
}
  
// import graph data from json
function importData() {
  boundaryVertices = [];
  edgePath = [];
  data = {vertices:[], edges:[]};
  update();
  data = JSON.parse(document.getElementById("jsonData").value);
  prepare_data(data);
  update();
}

// *UNUSED* import graph data from clipboard
function importFromClipboard() {
  boundaryVertices = [];
  edgePath = [];
  data = {vertices:[], edges:[]};
      navigator.clipboard.readText().then((copiedText) => {
      console.log(copiedText);
  });
  update_edge_data(data);
  prepare_data(data);
  update();
}

// store graph data to python and close session
function end_session() {
  eel.save_graph(export_graph());
  eel.update_server_status(false);
}


</script>
<script src="controller.js"></script>
</body>
</html>
