<!DOCTYPE html>
<html>
<head>
  <script type="text/javascript" src="eel.js"></script>
  <script src="d3.js"></script>
  <script>
    // notify server to render app
    eel.update_server_status(true);
  </script>
  <link rel="stylesheet" href="styles.css">
</head>
<body>

<br>
<div>
  <button id="btn-new" onclick="newGraph()">New</button>
  <button id="btn-off" onclick="end_session()">Save/Finish</button>
  <button id="btn-export" onclick="exportData()">Export data as json</button>
  <button id="btn-tikz" onclick="exportTikz()">Export tikz to clipboard</button>
  <button id="btn-import" onclick="importJson()">Import json data</button>
</div>

<div>
  <div id="paper-container"></div>
  <button id="btn-tikz" onclick="changeMode('edit')">Edit</button>
  <button id="btn-tikz" onclick="changeMode('analyze')">Analyze</button>
  <button id="btn-toggle_labels" onclick="toggleLabels()">Toggle vertex labels</button>
</div>

<br>
<!-- empty div where buttons dynamically rendered -->
<div id="actions"></div>


<script>
function changeMode(newMode) {
  mode = newMode;
  actions.innerHTML = '';

  // conditionally render buttons for each mode
  if (mode === 'edit') {
    const actions = document.getElementById('actions');

    const container = document.createElement('div');
    container.innerHTML = `
    <button id="btn-deselect" onclick="deselect()">Deselect all</button>
    <button id="btn-move" onclick="activateButton(this,'move')">Move</button>
    <button id="btn-place_filled" onclick="activateButton(this,'place_filled')">Place filled vertex</button>
    <button id="btn-place_unfilled" onclick="activateButton(this,'place_unfilled')">Place unfilled vertex</button>
    <button id="btn-toggle_color" onclick="activateButton(this,'toggle_color')">Toggle vertex color</button>
    <button id="btn-add_edge" onclick="activateButton(this,'place_edge')">Add edge</button>
    <button id="btn-add_hourglass" onclick="activateButton(this,'place_hourglass')">Add hourglass</button>
    <button id="btn-add_khourglass" onclick="activateButton(this,'place_khourglass')">Add k-hourglass</button>
    <button id="planar-dual" onclick="planarDual()">Planar dual</button>
    <button id="undo" onclick="undo()">Undo</button>
    `

    actions.appendChild(container);
  }

  else if (mode === 'analyze') {
    const actions = document.getElementById('actions');
    const container = document.createElement('div');
    container.innerHTML = `
    <button id="btn-deselect" onclick="deselect()">Deselect all</button>
    <button id="btn-trip1" onclick="activateButton(this,'trip1')">Trip1</button>
    <button id="btn-trip2" onclick="activateButton(this,'trip2')">Trip2</button>
    <button id="btn-trip3" onclick="activateButton(this,'trip3')">Trip3</button>
    <button id="btn-faces" onclick="toggleFaces()">Toggle Faces</button>
    <button id="btn-benzene" onclick="activateButton(this, 'benzene_move')">Benzene move</button>
    <button id="btn-square" onclick="activateButton(this, 'square_move')">Square move</button>
    `

    actions.appendChild(container);
  }
}

// global state variables
let mode = "";
const radius = 10;
var data = {vertices: [], edges:[]};
var boundaryVertices = [];
var edgePaths = {
  1: [],
  2: [],
  3: [],
}
var edgePathsCnt = {}
var showLabels = false;
var showFaces = false;


/* 
 *  Initialize Canvas
 */
var maxVertexId = 0;
var size = 600;
var body = d3.select("body");
var x = d3.scaleLinear().domain([-radius*1.1,radius*1.1]).range([0, size]);
var y = d3.scaleLinear().domain([-radius*1.1,radius*1.1]).range([size, 0]);

var selectedIds = []; // ids of selected vertices
var selected = []; // selected vertices

// init graph canvas
var svg = d3.select("#paper-container")
 .append("svg")
 .attr("id", "paper")
 .attr("width", size)
 .attr("height", size);

// init boundary circcle
var boundary_circle = svg.append("circle")
    .attr('id', 'boundary_circle')
    .attr('cx',x(0) )
    .attr('cy', y(0) )
    .attr('r',x(radius)-x(0));

// init groups for edges and vertices
var faces = svg.append("g").attr("id", "faces");
var edges = svg.append("g").attr("id", "edges");
var vertices = svg.append("g").attr("id", "vertices");

// get initial graph from backend
eel.get_graph()((g) => {
  data = g['data'];
  boundaryVertices = g['boundary_vertices'];
  preprocess_data();
  update();
});

// create new graph, prompt for number of vertices
function newGraph() {
  if(activeButton) {
    activeButton.style.borderStyle = 'outset';
  }
  if(activeMode) {
    activeMode.deactivate();
  }
  data = {vertices:[], edges:[]};
  update();

  let nvertices = prompt("Number of boundary vertices");
  for(i=0; i<nvertices;i++) {
    data.vertices[i] = {
      x: radius*Math.sin(i*2*Math.PI/nvertices),
      y: radius*Math.cos(i*2*Math.PI/nvertices),
      id: i,
      type: "filled"
    };
  }

  // send new graph to python
  eel.import_data(data_compressed())((d) => {
    data = d;
    preprocess_data();
    
    // FIXME: need to do the following
    // 1. update boundary vertices

    update();
  });
}


// return curve string for D3 to render edge
function hourglassPath(edge, hourglass_idx, trip_idx) {
  var pos1_x = edge.source.x;
  var pos1_y = edge.source.y;
  var pos2_x = edge.target.x;
  var pos2_y = edge.target.y;

  // init edge path count if nonexistent
  if (edgePathsCnt[edge.id].length <= hourglass_idx) {
      edgePathsCnt[edge.id][hourglass_idx] = [];
  }
  

  let pos = edgePathsCnt[edge.id][hourglass_idx].indexOf(trip_idx);

  // Apply offset when multiple trips use same edge
  // this offset scheme is a bit finicky with vertical edges
  const offset = 0.08;
  if (pos == 1) {
    theta = (pos2_y - pos1_y)/(pos2_x - pos1_x);
    pos1_x -= offset*Math.sin(theta);
    pos2_x -= offset*Math.sin(theta);
    pos1_y += offset*Math.cos(theta);
    pos2_y += offset*Math.cos(theta);
  }
  else if (pos == 2) {
    theta = (pos2_y - pos1_y)/(pos2_x - pos1_x);
    pos1_x += offset*Math.sin(theta);
    pos2_x += offset*Math.sin(theta);
    pos1_y -= offset*Math.cos(theta);
    pos2_y -= offset*Math.cos(theta);
  }

  var dx = pos2_x - pos1_x;
  var dy = pos2_y - pos1_y;
  var mid_x = (pos1_x+pos2_x)/2;
  var mid_y = (pos1_y+pos2_y)/2;
  var quater1_x = 0.75*pos1_x+0.25*pos2_x;
  var quater1_y = 0.75*pos1_y+0.25*pos2_y;
  var quater2_x = 0.25*pos1_x+0.75*pos2_x;
  var quater2_y = 0.25*pos1_y+0.75*pos2_y;
  var d = `M ${x(pos1_x)} ${y(pos1_y)} L ${x(pos2_x)} ${y(pos2_y)}`;

  var curveGenerator = d3.line()
    .curve(d3.curveNatural)
    .x(d=>x(d[0])).y(d=>y(d[1]));

  var d = "";

  var factor = (-(edge.weight-1)/2+hourglass_idx);
  var points = [
    [pos1_x, pos1_y],
    [quater1_x+factor*dy/8, quater1_y-factor*dx/8],
    [mid_x, mid_y],
    [quater2_x-factor*dy/8, quater2_y+factor*dx/8],
    [pos2_x, pos2_y]
  ];

  d += curveGenerator(points);

  return d;
}

// update graph svg based on data updates
function update() {
  // make sure data is valid format
  if (data == null) {
    console.log("data is null")
    data = {vertices:[], edges:[]};
  }

  // update path html element for each edge type
  // this generates pseudo-edges for each component of an hourglass edge
  edges.selectAll(".edge")
    .data(() => {
      var edgs = [];

      // clear count of paths on each edge
      edgePathsCnt = {};

      for (e of data.edges) {

        // init edge path count if nonexistent
        if (edgePathsCnt[e.id] == undefined) {
            edgePathsCnt[e.id] = {}

            // add array for each hourglass index
            for (var i=0; i<e.weight; i++) {
              edgePathsCnt[e.id][i] = [];
            }
        }

        for (var i=0; i<e.weight; i++) {
          let cnt = 0;

          // generate edge to render each time this edge appears in path
          if (edgePaths[1].indexOf(JSON.stringify([e.id, i])) > -1) {
            edgs.push({
              edge:e, 
              hourglass_idx:i,
              path: 1});
            cnt++;

            // push trip index to edge path count
            edgePathsCnt[e.id][i].push(1);
          }
          if (edgePaths[2].indexOf(JSON.stringify([e.id, i])) > -1) {
            edgs.push({
              edge:e, 
              hourglass_idx:i,
              path: 2});
            cnt++;
            edgePathsCnt[e.id][i].push(2);
          }
          if (edgePaths[3].indexOf(JSON.stringify([e.id, i])) > -1) {
            edgs.push({
              edge:e, 
              hourglass_idx:i,
              path: 3});
            cnt++;
            edgePathsCnt[e.id][i].push(3);
          }

          // if it doesn't appear in any edge path, push it once
          if (cnt == 0) {
            edgs.push({edge:e, hourglass_idx:i, path: 0});
          }
        }
      }
      return edgs;
    })
    .join("path")
    .attr("id", d=>"e"+d.edge.id)
    .attr("class", "edge")
    .attr("d", (d) => {
      return hourglassPath(d.edge, d.hourglass_idx, d.path);
    })
    .attr("fill", "none")
    // color edges if in edge path
    .classed("path_1", (d) => {
      var idx = edgePaths[1].indexOf(JSON.stringify([d.edge.id, d.hourglass_idx]));
      return (idx > -1 && d.path == 1);
    })
    .classed("path_2", (d) => {
      var idx = edgePaths[2].indexOf(JSON.stringify([d.edge.id, d.hourglass_idx]));
      return (idx > -1 && d.path == 2);
    })
    .classed("path_3", (d) => {
      var idx = edgePaths[3].indexOf(JSON.stringify([d.edge.id, d.hourglass_idx]));
      return (idx > -1 && d.path == 3);
    });

  // add circle html element for each vertex
  vertices.selectAll(".vertex").data(data.vertices)
    .join("circle")
    .attr("class", "vertex")
    .classed("unfilled", d=>d.type=="unfilled")
    .classed("filled", d=>d.type=="filled")
    .attr("cx", function(d) {
      return x(d.x)
    })
    .attr("cy", function(d) {
      return y(d.y)
    })
    .attr("r", 4)
    .classed("selected", d => {
      return selectedIds.indexOf(d.id) > -1;
    })


  // deactivate faces if not in analyze mode
  if (showFaces && mode != 'analyze') {
    toggleFaces(false);
  }

  // add labels if option selected
  vertices.selectAll(".vertex-label").data(data.vertices)
    .join("text")
    .attr("class", "vertex-label")
    .attr("x", function(d) {
      return x(d.x-0.3)
    })
    .attr("y", function(d) {
      return y(d.y+0.3)
    })
    .text(function(d) {
      if (!showLabels) {
        return "";
      }
      return d.id;
    });
}

// add edges to graph based on selected vertices
function addEdge(weight) {
  var selection = d3.selectAll(selected);
  console.log(selection)
  var selectedVertices = selection.data();
  for(var i=0; i < selectedVertices.length-1; i++) {
    data.edges.push({
      sourceId: selectedVertices[i].id, 
      targetId: selectedVertices[i+1].id, 
      weight: weight
    });
  }

  // FIXME: improve method for incremental updates
  eel.import_data(data_compressed())((d) => {
    data = d;
    preprocess_data();
    update();
  });
}



/*
 *  Fns for generating polygon hull html elements for boundary shapes
 */
function toggleFaces(arg=null) {
  // define helper functions
  // one for activating faces
  function activateFaces() {
    // if faces already exist, remove them
    d3.selectAll(".face").remove();

    eel.get_planar_faces()((face_data) => {
      // add labels for each face
      faces.selectAll(".face-label")
        .data(face_data)
        .join("text")
        .attr("class", "face-label")
        .attr("x", function(d) {
          let x_sum = 0;
          for (v of d) {x_sum += v[1];}
          return x(x_sum/d.length);
        })
        .attr("y", function(d) {
          let y_sum = 0;
          for (v of d) {y_sum += v[2];}
          return y(y_sum/d.length);
        })
        .attr("height", 10)
        .attr("width", 10)
        .text(function(d) {
          return face_data.indexOf(d);
        });

      // draw lines for each face
      let polygon = d3.line().curve(d3.curveLinearClosed);

      // add polygons to svg
      // generate pseudodata for each face
      faces.selectAll(".face")
        .data(face_data)
        .join("path")
        // pseudo data for each face
        .attr("d", d => {
          let polygon = d3.line().curve(d3.curveLinearClosed);

          // preprocess data
          let pts = [];
          for (v of d) {pts.push([x(v[1]), y(v[2])]);}
          const polygon_hull = polygon(pts.map(d => [d[0], d[1]]));

          return polygon_hull;
        })
        .on("click", (e, d) => {
          // select all vertices in face
          let face_vertices = d.map(v => v[0]);

          // depending on mode, perform different move
          if (moveMode == false) {
            return;
          }
          else if (moveMode === 'benzene') {
            benzeneMove(face_vertices);
          }
          else if (moveMode === 'square') {
            squareMove(face_vertices);
          }
        })
        .attr("class", "face");
    });
  }
  // and one for deactivating faces
  function deactivateFaces() {
    d3.selectAll(".face").remove();
    d3.selectAll(".face-label").remove();
  }

  // if arg is null, toggle faces
  if (arg == null) {
    showFaces = !showFaces;
  } else {
    showFaces = arg;
  }

  if (showFaces) {
    activateFaces();
  } else {
    deactivateFaces();
  }
}


function benzeneMove(vertex_ids) {
  // call backend fn and update graph  
  eel.benzene_move(vertex_ids)((d) => {
    // check if error
    if (typeof(d) == "string") {
      console.log(d);
      return;
    }
    
    data = d;
    preprocess_data();
    update();
  });
}

function squareMove(vertex_ids) {
  // call backend fn and update graph
  eel.square_move(vertex_ids)((d) => {
    // check for error
    if (typeof(d) == "string") {
      console.log(d);
      return;
    }

    data = d;
    preprocess_data();
    update();
    // update faces
    toggleFaces(true);
  })
}

function planarDual() {
  // call backend fn and update graph
  eel.planar_dual()((d) => {
    // check for error
    if (typeof(d) == "string") {
      console.log(d);
      return;
    }

    data = d;
    preprocess_data();
    update();
  })
}

function undo() {
  // call backend fn and update graph
  eel.undo()((d) => {
    // check for error
    if (typeof(d) == "string") {
      console.log(d);
      return;
    }

    data = d;
    preprocess_data();
    update();
  });
}




/* 
 *  Graph Import/Export fns
 */
// export graph data to JSON to clipboard
function exportData() {
  eel.get_graph()((d) => {
    navigator.clipboard.writeText(JSON.stringify(d['data']));
  });
}

// export LaTeX TikZ to clipboard
function export_tikz() {
  eel.get_tikz()((tikzString) => {
    navigator.clipboard.writeText(tikzString);
  })
}
  
// import graph data from json
function importJson() {
  let newData = prompt("Paste JSON here:");
  if (newData == null) {
    return;
  }

  // clear graph and update data
  boundaryVertices = [];
  edgePaths = {
    1: [],
    2: [],
    3: []
  };
  data = {vertices:[], edges:[]};
  update();
  data = JSON.parse(newData);

  // save to backend
  eel.import_data(data_compressed())((d) => {
    data = d;
    preprocess_data();
    update();
  });
}


/* 
 *  Backend Frontend Communication fns
 */
// store graph data to python and close session
function end_session() {
  eel.import_data(data_compressed());
  eel.update_server_status(false);
}

// bring graph to frontend and preprocess data
function preprocess_data() {
  maxVertexId = Math.max(...data.vertices.map(v => v.id)) + 1;

  // add references to source and target vertices
  data.edges.forEach(function(edge, i) {
    edge.source = data.vertices.filter(vertex => vertex.id == edge.sourceId)[0];
    edge.target = data.vertices.filter(vertex => vertex.id == edge.targetId)[0];
    edge.id = i;
  });
}

// convert graph data to exportable object
function data_compressed() {
  var d = {edges:[], vertices: []};

  // add edge info
  data.edges.forEach(function(edge) {
    let f = {
      weight : edge.weight,
      sourceId : edge.sourceId,
      targetId : edge.targetId
    };
    d.edges.push(f);
  });

  // add vertex info
  data.vertices.forEach(function(vertex) {
    let f = {
        x : vertex.x,
        y : vertex.y,
        id : vertex.id,
        type : vertex.type
      };
    d.vertices.push(f);
  });

  return d;
}


</script>
<script src="controller.js"></script>
</body>
</html>
